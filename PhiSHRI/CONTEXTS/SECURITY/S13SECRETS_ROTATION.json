{
  "door_code": "S13SECRETS_ROTATION",
  "semantic_path": "SECURITY.SECRETS.ROTATION_STRATEGIES",
  "aliases": ["secrets_rotation", "key_rotation", "credential_rotation", "password_rotation"],
  "context_bundle": {
    "summary": "Secrets rotation: Regularly change credentials to limit breach impact. Types: API keys, database passwords, encryption keys, OAuth client secrets, TLS certificates. Rotation strategies: Manual (risky, error-prone), Automated (scheduled rotation via tools), On-demand (rotate on suspected compromise). Tools: AWS Secrets Manager (auto-rotation for RDS, Lambda rotation functions), HashiCorp Vault (dynamic secrets, lease-based), Azure Key Vault (auto-rotation policies), Google Secret Manager. Best practices: Rotate every 30-90 days, use versioning (keep old version briefly for graceful transition), automate with infrastructure, monitor expiration alerts, test rotation in staging first, never hardcode secrets. Rotation process: Generate new secret → Update secret store → Deploy apps with new secret (zero-downtime: dual-version support) → Deactivate old secret after grace period.",
    "prerequisites": ["S05SECRETS", "T14TERRAFORM", "T15ANSIBLE"],
    "related_doors": ["S12API_SECURITY", "T13K8S_SECRETS", "W69ROLLING"],
    "onboarding": {
      "quick_start": "Secrets rotation: AWS Secrets Manager rotation: Create secret: aws secretsmanager create-secret --name db-password --secret-string 'mypassword'. Enable auto-rotation: aws secretsmanager rotate-secret --secret-id db-password --rotation-lambda-arn arn:aws:lambda:region:account:function:rotate-db-password --rotation-rules AutomaticallyAfterDays=30. Lambda rotation function: def lambda_handler(event, context): step = event['Step']; if step == 'createSecret': new_password = generate_password(); secrets_manager.put_secret_value(SecretId=arn, SecretString=new_password, VersionStages=['AWSPENDING']); elif step == 'setSecret': new_pw = secrets_manager.get_secret_value(SecretId=arn, VersionStage='AWSPENDING')['SecretString']; db.execute('ALTER USER app PASSWORD ?', new_pw); elif step == 'testSecret': test_connection(new_password); elif step == 'finishSecret': secrets_manager.update_secret_version_stage(SecretId=arn, VersionStage='AWSCURRENT', MoveToVersionId=new_version, RemoveFromVersionId=old_version). HashiCorp Vault: Dynamic secrets: vault read database/creds/my-role; # Vault generates temp DB creds, auto-revoked after TTL. Kubernetes: External Secrets Operator syncs from Vault/AWS: apiVersion: external-secrets.io/v1beta1; kind: ExternalSecret; spec: {secretStoreRef: {name: vault}, target: {name: db-secret}, data: [{secretKey: password, remoteRef: {key: db-password}}]}. App reads secret: Use latest version, handle rotation gracefully (retry on auth fail with refreshed secret).",
      "full_context_path": "/PhiDEX/MASTER_CODEX/06_SECURITY/SECURITY_HARDENING_GUIDE.md",
      "common_patterns": [
        "AWS Secrets Manager get secret: import boto3; client = boto3.client('secretsmanager'); response = client.get_secret_value(SecretId='db-password'); password = json.loads(response['SecretString'])['password']; db_conn = create_connection(password=password)",
        "Rotation Lambda (RDS): def rotate(event, context): arn = event['SecretId']; token = event['ClientRequestToken']; step = event['Step']; if step == 'createSecret': new_pw = secrets.generate_random_password(PasswordLength=32); secrets.put_secret_value(SecretId=arn, SecretString=new_pw, VersionStages=['AWSPENDING'], ClientRequestToken=token); elif step == 'setSecret': new = secrets.get_secret_value(SecretId=arn, VersionStage='AWSPENDING'); rds_client.modify_db_instance(DBInstanceIdentifier='mydb', MasterUserPassword=new['SecretString']); # More steps: testSecret, finishSecret",
        "Vault dynamic DB creds: vault write database/config/postgres plugin_name=postgresql-database-plugin connection_url='postgresql://{{username}}:{{password}}@localhost:5432/mydb' allowed_roles='my-role'; vault write database/roles/my-role db_name=postgres creation_statements='CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD ''{{password}}'' VALID UNTIL ''{{expiration}}''; default_ttl=1h max_ttl=24h; creds = vault.read('database/creds/my-role'); # Returns {username, password}, auto-revoked",
        "Azure Key Vault rotation policy: az keyvault secret set-attributes --vault-name my-vault --name db-password --expires '2025-12-31'; # Set expiration, monitor with alerts",
        "Dual-version support (zero-downtime): old_secret = secrets.get('AWSPREVIOUS'); new_secret = secrets.get('AWSCURRENT'); try: connect(new_secret); except AuthError: connect(old_secret); # Fallback during rotation",
        "Terraform secret rotation: resource \"aws_secretsmanager_secret_rotation\" \"db\" { secret_id = aws_secretsmanager_secret.db.id; rotation_lambda_arn = aws_lambda_function.rotate.arn; rotation_rules { automatically_after_days = 30 } }",
        "Kubernetes external secret: apiVersion: external-secrets.io/v1beta1; kind: ExternalSecret; metadata: {name: app-secret}; spec: {refreshInterval: 1h, secretStoreRef: {name: aws-sm}, target: {name: app-secret}, data: [{secretKey: DB_PASSWORD, remoteRef: {key: prod/db-password}}]}",
        "Monitoring expiration: aws secretsmanager list-secrets --filters Key=name,Values=db-password | jq '.SecretList[].NextRotationDate'; # Alert if <7 days",
        "Certificate rotation (certbot): certbot renew --deploy-hook 'systemctl reload nginx'; # Auto-renew Let's Encrypt certs, reload nginx",
        "API key rotation: Generate new key → Add to allowed keys (both old and new active) → Update clients → After grace period (7 days), revoke old key"
      ],
      "known_errors": []
    },
    "resources": {
      "docs": ["/PhiDEX/MASTER_CODEX/06_SECURITY/SECURITY_HARDENING_GUIDE.md"],
      "code": [],
      "tests": [],
      "errors": []
    },
    "metadata": {
      "last_updated": "2025-11-20T22:00:00Z",
      "confidence": 1.0,
      "usage_count": 0,
      "success_rate": 0.0,
      "tags": ["secrets_rotation", "key_rotation", "aws_secrets_manager", "vault", "credential_management", "security"],
      "category": "SECURITY",
      "subcategory": "SECRETS",
      "version": "1.0.0",
      "tested_on": ["AWS Secrets Manager", "HashiCorp Vault", "Azure Key Vault", "Kubernetes"],
      "agent_affinity": ["VSCC", "CMDC", "TERMC"]
    }
  }
}
