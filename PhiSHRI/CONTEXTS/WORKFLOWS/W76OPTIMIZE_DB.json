{
  "door_code": "W76OPTIMIZE_DB",
  "semantic_path": "WORKFLOWS.PERFORMANCE.DATABASE_OPTIMIZATION",
  "aliases": ["database_optimization", "db_optimization", "query_tuning", "indexes", "query_optimization", "sql_performance"],
  "context_bundle": {
    "summary": "Database optimization improves query performance: Indexing (B-tree for range queries O(log n), Hash for equality, covering indexes include all query columns), query tuning (EXPLAIN plans, avoid SELECT *, use JOINs efficiently, limit result sets), connection pooling (reuse connections, typical pool size 2Ã—CPU cores), caching (Redis for query results, materialized views), partitioning (horizontal by range/hash, vertical by columns), denormalization (trade storage for read speed). Tools: EXPLAIN/EXPLAIN ANALYZE (execution plans), pg_stat_statements (Postgres query stats), slow query log (MySQL). Targets: Query time <100ms, index hit ratio >95%, connection pool utilization 70-80%.",
    "prerequisites": ["W72CACHING", "E07DATABASE_ERRORS"],
    "related_doors": ["W86METRICS", "T10OBSERVABILITY", "W73PROFILING"],
    "onboarding": {
      "quick_start": "Database optimization techniques: Indexes - CREATE INDEX idx_users_email ON users(email); # B-tree index for WHERE email='...'. Covering index: CREATE INDEX idx_users_name_email ON users(name, email); # Query: SELECT name, email FROM users WHERE name='...' uses index only. Query tuning - EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id=123; # Shows execution plan, cost, actual time. Avoid: SELECT * (fetch only needed columns), N+1 queries (use JOIN), missing indexes (check seq scans). Connection pooling (Python): from sqlalchemy.pool import QueuePool; engine = create_engine('postgresql://...', poolclass=QueuePool, pool_size=10, max_overflow=20). Materialized views (Postgres): CREATE MATERIALIZED VIEW user_summary AS SELECT user_id, COUNT(*) as order_count FROM orders GROUP BY user_id; REFRESH MATERIALIZED VIEW user_summary; # Pre-computed aggregates. Partitioning (Postgres): CREATE TABLE orders_2024 PARTITION OF orders FOR VALUES FROM ('2024-01-01') TO ('2025-01-01'); # Range partition by date. Monitoring: SELECT schemaname, tablename, idx_scan, seq_scan FROM pg_stat_user_tables; # Index usage. Target: idx_scan >> seq_scan.",
      "full_context_path": "/PhiDEX/MASTER_CODEX/08_PERFORMANCE/PERFORMANCE_OPTIMIZATION_GUIDE.md",
      "common_patterns": [
        "Create B-tree index: CREATE INDEX idx_orders_created ON orders(created_at); # Fast range queries: WHERE created_at > '2024-01-01'",
        "Composite index: CREATE INDEX idx_orders_user_status ON orders(user_id, status); # WHERE user_id=? AND status='pending'",
        "EXPLAIN query: EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM orders WHERE user_id=123; # Shows Index Scan vs Seq Scan, cost, actual rows",
        "Avoid N+1 queries: SELECT * FROM users JOIN orders ON users.id=orders.user_id; # Instead of: users = SELECT * FROM users; for user in users: SELECT * FROM orders WHERE user_id=user.id",
        "Connection pooling (Java): HikariConfig config = new HikariConfig(); config.setMaximumPoolSize(10); HikariDataSource ds = new HikariDataSource(config)",
        "Query caching (Redis): query_hash = hashlib.md5(query.encode()).hexdigest(); cached = redis.get(query_hash); if not cached: result = db.execute(query); redis.setex(query_hash, 300, json.dumps(result))",
        "Materialized view refresh: REFRESH MATERIALIZED VIEW CONCURRENTLY user_summary; # Non-blocking refresh",
        "Partition pruning: SELECT * FROM orders WHERE created_at BETWEEN '2024-01-01' AND '2024-01-31'; # Query only 2024_01 partition",
        "Index monitoring (Postgres): SELECT indexrelname, idx_scan, idx_tup_read, idx_tup_fetch FROM pg_stat_user_indexes WHERE idx_scan = 0; # Find unused indexes",
        "Slow query log (MySQL): SET GLOBAL slow_query_log = 'ON'; SET GLOBAL long_query_time = 1; # Log queries >1s"
      ],
      "known_errors": []
    },
    "resources": {
      "docs": ["/PhiDEX/MASTER_CODEX/08_PERFORMANCE/PERFORMANCE_OPTIMIZATION_GUIDE.md"],
      "code": [],
      "tests": [],
      "errors": []
    },
    "metadata": {
      "last_updated": "2025-11-20T22:00:00Z",
      "confidence": 1.0,
      "usage_count": 0,
      "success_rate": 0.0,
      "tags": ["database_optimization", "indexes", "query_tuning", "sql", "postgres", "mysql", "connection_pooling", "partitioning"],
      "category": "WORKFLOWS",
      "subcategory": "PERFORMANCE",
      "version": "1.0.0",
      "tested_on": ["PostgreSQL", "MySQL", "SQL Server", "Oracle"],
      "agent_affinity": ["VSCC", "CMDC", "TERMC"]
    }
  }
}
