{
  "door_code": "W84LOGGING",
  "semantic_path": "WORKFLOWS.OBSERVABILITY.STRUCTURED_LOGGING",
  "aliases": [
    "logging",
    "structured_logging",
    "json_logs",
    "log_levels",
    "logger"
  ],
  "context_bundle": {
    "summary": "Structured logging for observability: Use JSON format for machine parsing, include context (request_id, user_id, service_name), log levels (DEBUG <INFO <WARNING <ERROR <CRITICAL), centralized aggregation (ELK, Splunk, Datadog). Best practices: Never log secrets/PII, use correlation IDs across services, sample verbose logs (1% of DEBUG), buffer/batch for performance. Python: import logging; logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'). Structured (JSON): import structlog; log = structlog.get_logger(); log.info('user.login', user_id=123, ip='1.2.3.4'). Log rotation: RotatingFileHandler(maxBytes=10MB, backupCount=5). Metrics: Log volume, error rate, p95 latency from logs.",
    "prerequisites": [
      "W86METRICS",
      "T10OBSERVABILITY"
    ],
    "related_doors": [
      "W85TRACING",
      "E06CIRCUIT_BREAKER",
      "W82WEBHOOKS"
    ],
    "onboarding": {
      "quick_start": "Structured logging: Python standard: import logging; logger = logging.getLogger(__name__); logger.setLevel(logging.INFO); handler = logging.StreamHandler(); handler.setFormatter(logging.Formatter('{\"time\": \"%(asctime)s\", \"level\": \"%(levelname)s\", \"message\": \"%(message)s\"}')); logger.addHandler(handler); logger.info('User logged in', extra={'user_id': 123, 'ip': '1.2.3.4'}). Python structlog (better): import structlog; structlog.configure(processors=[structlog.processors.TimeStamper(fmt='iso'), structlog.processors.JSONRenderer()]); log = structlog.get_logger(); log.info('user.login', user_id=123, session_id='abc', duration_ms=250). Node.js (Winston): const winston = require('winston'); const logger = winston.createLogger({ level: 'info', format: winston.format.json(), transports: [new winston.transports.Console()] }); logger.info('User login', { userId: 123, ip: '1.2.3.4' }). Go (zap): import \"go.uber.org/zap\"; logger, _ := zap.NewProduction(); logger.Info(\"user login\", zap.Int(\"user_id\", 123), zap.String(\"ip\", \"1.2.3.4\")); defer logger.Sync(). Log levels: DEBUG (verbose, dev), INFO (important events), WARNING (unexpected but handled), ERROR (failures), CRITICAL (system down). Rotation: from logging.handlers import RotatingFileHandler; handler = RotatingFileHandler('app.log', maxBytes=10*1024*1024, backupCount=5). Correlation ID: import uuid; request_id = str(uuid.uuid4()); log.bind(request_id=request_id).info('Processing request').",
      "full_context_path": "/PhiDEX/MASTER_CODEX/03_DEVELOPMENT/DEVELOPMENT_WORKFLOWS_COMPREHENSIVE_GUIDE.md",
      "common_patterns": [
        "Python structlog config: structlog.configure(processors=[structlog.stdlib.filter_by_level, structlog.processors.TimeStamper(fmt='iso'), structlog.processors.StackInfoRenderer(), structlog.processors.format_exc_info, structlog.processors.JSONRenderer()], context_class=dict, logger_factory=structlog.stdlib.LoggerFactory(), cache_logger_on_first_use=True)",
        "Contextual logging: log = logger.bind(request_id=request.id, user_id=request.user.id); log.info('Processing order', order_id=456); log.error('Payment failed', error=str(e))",
        "Winston transports (Node.js): transports: [new winston.transports.Console(), new winston.transports.File({ filename: 'error.log', level: 'error' }), new winston.transports.File({ filename: 'combined.log' })]",
        "Go zap production logger: logger, _ := zap.NewProduction(); sugar := logger.Sugar(); sugar.Infow('User action', 'user_id', 123, 'action', 'purchase', 'amount', 99.99)",
        "Log sampling (reduce volume): structlog.configure(processors=[structlog.processors.JSONRenderer()], wrapper_class=structlog.make_filtering_bound_logger(logging.INFO))",
        "Never log sensitive data: log.info('Payment processed', user_id=user.id, amount=payment.amount); # NEVER: password, token, SSN",
        "ELK stack ingestion: Use Filebeat to ship logs → Logstash to parse → Elasticsearch to index → Kibana to visualize",
        "Correlation across services: headers['X-Request-ID'] = request_id; log.bind(request_id=request_id); # Pass to downstream services",
        "Performance: Use async logging or batch writes to avoid I/O blocking: handler = QueueHandler(queue.Queue())",
        "Kubernetes logs: kubectl logs -f pod-name -c container-name --tail=100; # JSON logs parsed automatically"
      ],
      "known_errors": []
    },
    "resources": {
      "docs": [
        "/PhiDEX/MASTER_CODEX/03_DEVELOPMENT/DEVELOPMENT_WORKFLOWS_COMPREHENSIVE_GUIDE.md"
      ],
      "code": [],
      "tests": [],
      "errors": []
    },
    "metadata": {
      "last_updated": "2025-11-20T22:00:00Z",
      "confidence": 1.0,
      "usage_count": 0,
      "success_rate": 0.0,
      "tags": [
        "logging",
        "structured_logging",
        "json",
        "structlog",
        "winston",
        "zap",
        "observability"
      ],
      "category": "WORKFLOWS",
      "subcategory": "OBSERVABILITY",
      "version": "1.0.0",
      "tested_on": [
        "Python",
        "Node.js",
        "Go",
        "Java",
        "ELK Stack"
      ],
      "agent_affinity": [
        "VSCC",
        "CMDC",
        "TERMC"
      ],
      "size_bytes": 5212,
      "token_estimate": 1303.0
    }
  }
}
